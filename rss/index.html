<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Google Summer of Code 2014]]></title><description><![CDATA[Creating a REST API for humans]]></description><link>http://127.0.0.1:2368/</link><generator>Ghost v0.4.2</generator><lastBuildDate>Sun, 08 Jun 2014 15:40:40 GMT</lastBuildDate><atom:link href="http://127.0.0.1:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Week 3 - Developing Course APIs]]></title><description><![CDATA[<p>I left last week with the idea of implementing the next two calls.</p>

<pre><code>GET /api/students/[student_id]/courses  
GET /api/instructors/[instructor_id]/courses  
</code></pre>

<p>The former would retrive a list courses that a student is enrolled in and the latter would get the list of courses an instructor teaches.</p>

<p>The emphasis in these two calls was to re-use the SQL queries for all calls that returned a list of courses. This was best accomplished by adding the following where clauses for each of the .</p>

<pre><code>WHERE ... AND ('%s' = 'garbage_value' OR title like '%%s%') AND ...;  
</code></pre>

<p>If a certain variable (like <code>title</code>) wasn't present in the URL parameters, it is assigned a garbage value. Therefore, the first part of the clause is <code>true</code> and this part doesn't affect the whole query in general. If the variable is present, the first part of the query is <code>false</code> and the second part determines if it's <code>true</code> overall.</p>

<p>After all that, we are having second thoughts about the complexity of the query. I will try an alternative version where I develop the <code>WHERE</code> clause using PHP and check which one is faster.</p>

<p>Additional API calls were implemented for students and instructors as follows. I believe they are self explanatory.</p>

<pre><code>GET /api/students/[student_id]/courses/[course_id]  
GET /api/students/[student_id]/courses?title=[title]&amp;category_id=[category_id]&amp;primary_language=[primary_language]

GET /api/instructors/[instructor_id]/courses/[course_id]  
GET /api/instructors/[instructor_id]/courses?title=[title]&amp;category_id=[category_id]&amp;primary_language=[primary_language]
</code></pre>

<p>Another part that I completed in the week was to develop the APIs for course categories (except <code>PUT</code> pending some discussions with my mentor). (Note that these course categories are different from question categories and I would need to create an API for them later in the summer.)</p>

<p>This week also saw some changes in the structure of the code. Some of the logic that I kept in <code>core/api_functions.php</code> was moved to a <code>shared</code> directory. Core now contains functions related to the core functioning of the API (like logging and token management.)</p>

<p>I also changed the function <code>print_error</code> to <code>print_message</code>. The first argument specifies if it's an error or a success message to be printed. Chaning the function also involved adding a logging functionality to messages. (Remember, as of last week, only successes were being logged?)</p>]]></description><link>http://127.0.0.1:2368/week-3-developing-course-apis/</link><guid isPermaLink="false">901e68e2-f6b9-46b5-8678-88666425e33c</guid><dc:creator><![CDATA[Shaumik Daityari]]></dc:creator><pubDate>Sun, 08 Jun 2014 15:36:07 GMT</pubDate></item><item><title><![CDATA[Week 2 - Making the first API calls]]></title><description><![CDATA[<p>After successfully creating the login and logout API calls, the next step was to create some basic API calls. The very first area that we decided to implement was <code>courses</code>.</p>

<p>The following API calls were implemented.  </p>

<pre><code>GET /api/courses/  
GET /api/courses/[course_id]  
GET /api/courses?title=[title]&amp;category_id=[category_id]&amp;primary_language=[primary_language]  
</code></pre>

<p>In my previous post, I mentioned that I hadn't implemented how to decide the access level of a member. This week, I added the feature by making queries to two different tables- one for members and the other for admins. Since that was accomplished, I could proceed with two courses related calls for instructors and students.</p>

<pre><code>GET /api/students/[student_id]/courses  
GET /api/instructors/[instructor_id]/courses  
</code></pre>

<p>The first would return list the courses that a student is enrolled in and the second would return the list of courses that an instructor teaches.</p>

<p>I had created a function last week to authenticate an access token. Because of the two above APIs, I needed to cross check if the access token matched the student or instructor ID provided in the URL above. That would mean an extra query. To avoid that, I added an extra argument to the authentication function that returns the <code>member_id</code> along with the token. Here's how it looks.</p>

<pre><code>function (..., $return_member_id = false) {  
    ...
    return array($token, $member_id);
}
</code></pre>

<p>How do I get the value?</p>

<pre><code>list($token, $member_id) = get_access_token(..., true);  
</code></pre>

<p>Pretty Pythonic, isn't it?</p>

<p>Another important task accomplished in the week is the logging of all API calls. The request URI, token, HTTP method, IP address and the response are logged in the database.</p>

<p>One last thing to do is to create logs in case of errors.</p>]]></description><link>http://127.0.0.1:2368/week-2-making-the-first-api-calls/</link><guid isPermaLink="false">70df675c-5fa0-4168-a110-8d261795b2c4</guid><dc:creator><![CDATA[Shaumik Daityari]]></dc:creator><pubDate>Sun, 01 Jun 2014 08:31:00 GMT</pubDate></item><item><title><![CDATA[Week 1 - The coding starts]]></title><description><![CDATA[<p>After completing a lot of discussions on what API calls we should have, we decided to go with four basic sets of API calls- <code>courses</code> for course related information, <code>instructors</code> for calls that instructors would use (to see the list of students for instance), <code>students</code> for calls that would be used by students and <code>tests</code> for test related calls.</p>

<p>The next task was to decide the access levels. We decided to have five.</p>

<pre><code>    define("ADMIN_ACCESS_LEVEL", 1);
    define("INSTRUCTOR_ACCESS_LEVEL", 2);
    define("STUDENT_ACCESS_LEVEL", 3);
    define("TOKEN_ACCESS_LEVEL", 4);
    define("PUBLIC_ACCESS_LEVEL", 5);
</code></pre>

<p>The <code>TOKEN_ACCESS_LEVEL</code> gives access to anyone with a valid access token, which would be passed as a header <code>x-AT-API-TOKEN</code>. Those calls that do not require a token would have a <code>PUBLIC_ACCESS_LEVEL</code>.</p>

<p>The next step was to start with a few basic calls. I had already worked on a dummy class with Toro to demonstrate the handling of different kinds of variables. For obvious reasons, the two that I had to start with were <code>/login/</code> and <code>/logout/</code>.</p>

<p>The existing code that handled the login in ATutor (<code>/include/login_functions.inc.php</code>) wasn't really modular and couldn't be reused by me. Therefore, I had to check how it worked and emulate the same.</p>

<p>I came up with a rudimentary version of the login function by adding checks for the status of the account. I am yet to put checks for the number of login attempts though.</p>

<p>On successful login, you are provided the API token, which you must use in every subsequent API call.</p>

<p>The token is generated by hashing a combination of the <code>member_id</code>, timestamp and a random number. It is then stored in a table along with an expiry date, which is 24 hours from the time of generation or last modification.</p>

<p>The logout function is also fairly simple. It removes the entry for the token in the database and returns a success message.</p>

<p>You can check the latest code <a href='https://github.com/sdaityari/ATutor/pull/24/files' >here</a>.</p>]]></description><link>http://127.0.0.1:2368/google-summer-of-code-week-1-the-coding-starts/</link><guid isPermaLink="false">38160a56-4cef-49d0-96d8-f8b7fdc205aa</guid><category><![CDATA[api]]></category><category><![CDATA[week 1]]></category><dc:creator><![CDATA[Shaumik Daityari]]></dc:creator><pubDate>Sun, 25 May 2014 15:39:35 GMT</pubDate></item><item><title><![CDATA[Discussions on the ATutor API - Community Bonding Period]]></title><description><![CDATA[<p>It's been four weeks since the <a href='http://www.google-melange.com/gsoc/projects/list/google/gsoc2014' >GSoC 2014 results</a> were declared. I was selected by Inclusive Design Institute for developing a public API for their project, ATutor. I had worked with them last year in the GSoC too and my last year mentor, <a href='https://twitter.com/twitanvk' >Alexey Novak</a>, was going to mentor me yet again.</p>

<p>Four weeks of community bonding time is a long time and I have utilized this time in discussing the future strategies with my mentor. We had quite a few things to decide because we wanted a good API at the end of the summer. For reference, we took the examples of <a href='https://developer.github.com/v3/' >GitHub</a> and <a href='http://amara.readthedocs.org/en/latest/api.html' >Amara</a> APIs.</p>

<h2 id="creatingamodule">Creating a module</h2>

<p>We decided that although we would separate the API code from the rest of the ATutor code, we wanted to let the admin have the choice of whether to enable the API. The best way to do it within ATutor was to <a href='http://www.atutor.ca/development/documentation/modules.html' >create a module</a> (BTW, I really dislike reading documentation). If the module was not activated and someone was trying to access the API, we would just show them a message that the feature is disabled.</p>

<h2 id="choosingawebrouterclass">Choosing a web router class</h2>

<p>ATutor is written in core PHP. True that there are a lot of functions within ATutor that do most of the heavy lifting, but it still remains in core PHP. Up until now, there was no need to develop a routing class. However, an API would need a router (unless you plan to create separate directories and pages for each function).</p>

<p>We narrowed down certain options, but finally decided to go with <a href='http://toroweb.org/' >Toro</a>. Although people call it a 'micro framework', the source just consists of a file with 120 odd lines. It was just perfect to add to ATutor. Toro is also designed specifically for creating a REST framework. To top it all, the 'Hello World' function is so simple, yet elegant.</p>

<pre><code>&lt;?php

class MainHandler {  
    function get() {
        echo "Hello, world";
    }
}

Toro::serve(array(  
    "/" =&gt; "MainHandler",
));
</code></pre>

<p>An important thing to note is that Toro does the routing, but the structure of the app is largely dependent on the developer. Having worked with Django so much, I decided to go with the flow. I split the core API into individual apps, each with their own <code>urls.php</code> and <code>router_classes.php</code>, which contains the routes and the handlers, respectively. Have a look at it <a href='https://github.com/sdaityari/ATutor/tree/toro/api' >here</a>.</p>

<h2 id="makingthelist">Making the list</h2>

<p>Lastly, there remained one uphill task before I could start coding (<em>Yeah, I hadn't started already!</em>) I had to create a list of possible API calls that I would implement, with details of what parameters would be passed on with each request and what would be returned. The user access levels were to be decided later, once we moved on to implementing the user authentication. I have come up with a preliminary list of <code>GET</code>, <code>POST</code>, <code>PUT</code> and <code>DELETE</code> calls, and I can start coding (<em>finally</em>) once it is verified by my mentor.</p>

<p>The official coding begins in two more days, and it's going to be real fun, much like <a href='http://dada.theblogbowl.in/search/label/google%20summer%20of%20code' >last year</a>. Looking forward to crafting some mean looking code.</p>]]></description><link>http://127.0.0.1:2368/discussions-on-the-atutor-api/</link><guid isPermaLink="false">912bf063-4325-4d70-a902-8df7a5fde791</guid><category><![CDATA[atutor]]></category><category><![CDATA[api]]></category><category><![CDATA[module]]></category><category><![CDATA[router]]></category><category><![CDATA[toro]]></category><dc:creator><![CDATA[Shaumik Daityari]]></dc:creator><pubDate>Sat, 17 May 2014 12:24:22 GMT</pubDate></item></channel></rss>